/*
 * generated by Xtext 2.25.0
 */
package dk.sdu.mmmi.mdsd.generator

import dk.sdu.mmmi.mdsd.math.Div
import dk.sdu.mmmi.mdsd.math.DomainModel
import dk.sdu.mmmi.mdsd.math.ExternalBinding
import dk.sdu.mmmi.mdsd.math.LetBinding
import dk.sdu.mmmi.mdsd.math.MathExp
import dk.sdu.mmmi.mdsd.math.MathNumber
import dk.sdu.mmmi.mdsd.math.Minus
import dk.sdu.mmmi.mdsd.math.Mult
import dk.sdu.mmmi.mdsd.math.Plus
import dk.sdu.mmmi.mdsd.math.VarBinding
import dk.sdu.mmmi.mdsd.math.VariableUse
import java.util.ArrayList
import java.util.List
import javax.swing.JOptionPane
import org.eclipse.emf.common.util.BasicEList
import org.eclipse.emf.common.util.BasicEMap
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.common.util.EMap
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import dk.sdu.mmmi.mdsd.math.Parenthesis

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathGenerator extends AbstractGenerator {

	static EMap<String, String> variables;	
	static List<String> ifparams;
	static EList<String> ifmap;
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		ifparams = new ArrayList<String>
		ifparams.add("n")
		ifparams.add("m")
		ifparams.add("j")	
		
		val math = resource.allContents.filter(MathExp).next
		math.parse
		//displayPanel(variables)	
	   for (e : resource.allContents.toIterable.filter(DomainModel)) {
            fsa.generateFile(
            e.element.name + ".java",
        	e.compile)
        }
	}
	
	private def compile(DomainModel model)
	'''
	package math_expression;
	public class «model.element.name» {
		
		«FOR variable : model.element.math.variables»
			public int «variable.name»;
		«ENDFOR»
		
		«IF !model.element.externals.isEmpty»
		private External external;
		
		public «model.element.name»(External external){
			this.external = external;
		}
		«ENDIF»
		
		public void compute() {
			«FOR variable : variables»
				«variable.getKey» = «variable.getValue»;
			«ENDFOR»
		}
		
		«IF !model.element.externals.isEmpty»
		public interface External {
			«FOR external : model.element.externals»
				public int «external.name»(«FOR parameter : external.parameters.serveParams»«parameter»«ENDFOR»);
			«ENDFOR»
		}
		«ENDIF»
	}
	'''
	
	def EList<String> serveParams(EList<String> list){
		ifmap = new BasicEList<String>
		for (type : list) {
				val splitted = type.split(",")	
				val iterator = splitted.iterator
				while(iterator.hasNext){
					val finalType = iterator.next
					if(!iterator.hasNext){
					ifmap.add(finalType + " " + ifparams.get(0))
					ifparams.remove(0)
					} else {
					ifmap.add(finalType + " " + ifparams.get(0)+",")
					ifparams.remove(0)
					}
				}
		}
		return ifmap
	}
	
	def void displayPanel(EMap<String, String> result) {
		var resultString = ""
		for (entry : result.entrySet()) {
         	resultString += "var " + entry.getKey() + " = " + entry.getValue() + "\n"
        }
		
		JOptionPane.showMessageDialog(null, resultString ,"Math Language", JOptionPane.INFORMATION_MESSAGE)
	}
	
	def static parse(MathExp math) {
		variables = new BasicEMap()
		for(varBinding: math.variables)
			
			varBinding.computeExpression()
		variables
	}
	
	def static dispatch String computeExpression(VarBinding binding) {
		variables.put(binding.name, binding.expression.computeExpression())
		return variables.get(binding.name)
	}
	
	def static dispatch String computeExpression(ExternalBinding binding) {
		var parameterList = ""
		val iterator = binding.parameters.iterator
		while(iterator.hasNext){
			val parameter = iterator.next
			if(!iterator.hasNext){
				parameterList += parameter.computeExpression
			} else {
				parameterList += parameter.computeExpression + ","
			}
		}
		"this.external." + binding.ref.name + "(" + parameterList + ")"
	}
	
	def static dispatch String computeExpression(MathNumber exp) {
		exp.value.toString
	}
	
	def static dispatch String computeExpression(Parenthesis exp) {
		'(' + exp.exp.computeExpression + ')'
		
	}
	def static dispatch String computeExpression(Plus exp) {
		exp.left.computeExpression + " + " + exp.right.computeExpression
	}
	
	def static dispatch String computeExpression(Minus exp) {
		exp.left.computeExpression + " - " + exp.right.computeExpression
	}
	
	def static dispatch String computeExpression(Mult exp) {
		exp.left.computeExpression + " * " + exp.right.computeExpression
	}
	
	def static dispatch String computeExpression(Div exp) {
		exp.left.computeExpression + " / " +  exp.right.computeExpression 
	}

	def static dispatch String computeExpression(LetBinding exp) {
		exp.body.computeExpression
	}
	
	def static dispatch String computeExpression(VariableUse exp) {
		exp.ref.computeBinding
	}

	def static dispatch String computeBinding(VarBinding binding){
		if(!variables.containsKey(binding.name))
			binding.computeExpression()			
		binding.name
	}
	
	def static dispatch String computeBinding(LetBinding binding){
		'(' + binding.binding.computeExpression + ')'
	}
	
}
